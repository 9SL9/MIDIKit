//
//  ThruConnection.swift
//  MIDIKit â€¢ https://github.com/orchetect/MIDIKit
//

// Apple CoreMIDI play-through connection documentation:
// https://developer.apple.com/documentation/coremidi/midi_thru_connection
//
// Thru connections are observable in:
// ~/Library/Preferences/ByHost/com.apple.MIDI.<UUID>.plist
// but you can't manually modify the plist file.

import Foundation
import CoreMIDI
@_implementationOnly import OTCore
@_implementationOnly import MIDIKitC

extension MIDI.IO {
    
    /// A managed MIDI thru connection created in the system by the `Manager`.
    ///
    /// CoreMIDI MIDI play-through connections can be non-persistent (client-owned, auto-disposed when `Manager` deinits) or persistent (maintained even after system reboots).
    public class ThruConnection {
        
        public private(set) var thruConnectionRef: MIDIThruConnectionRef? = nil
        
        public private(set) var outputs: [OutputEndpoint]
        
        public private(set) var inputs: [InputEndpoint]
        
        public private(set) var lifecycle: Lifecycle
        
        public private(set) var params: MIDIThruConnectionParams? = nil
        
        /// - Parameters:
        ///   - outputs: One or more output endpoints, maximum of 8.
        ///   - inputs: One or more input endpoints, maximum of 8.
        ///   - lifecycle: Non-persistent or persistent.
        ///   - params: Optionally supply custom parameters for the connection. `nil` employs default parameters.
        internal init(outputs: [OutputEndpoint],
                      inputs: [InputEndpoint],
                      _ lifecycle: Lifecycle = .nonPersistent,
                      params: MIDIThruConnectionParams? = nil) {
            
            // truncate arrays to 8 members or less;
            // CoreMIDI thru connections can only have up to 8 outputs and 8 inputs
            
            self.outputs = Array(outputs.prefix(8))
            self.inputs = Array(inputs.prefix(8))
            self.lifecycle = lifecycle
            self.params = params
            
        }
        
        deinit {
            
            _ = try? dispose()
            
        }
        
    }
    
}

extension MIDI.IO.ThruConnection {
    
    internal func create(in manager: MIDI.IO.Manager) throws {
        
        var newConnection = MIDIThruConnectionRef()
        
        var params = self.params ?? {
            // set up default parameters if params were not supplied
            // (parameters can be altered later using MIDIThruConnectionSetParams on the thruConnectionRef reference)
            
            var newParams = MIDIThruConnectionParams()
            
            MIDIThruConnectionParamsInitialize(&newParams) // fill with defaults
            
            // MIDIThruConnectionParams Properties:
            //  .outputs
            //      MIDIThruConnectionEndpoint tuple (initial size: 8). All MIDI generated by these outputs is
            //      routed into this connection for processing and distribution to inputs.
            //  .numSources
            //      The number of valid outputs in the .outputs tuple.
            //  .inputs
            //      MIDIThruConnectionEndpoint tuple (initial size: 8). All MIDI output from the connection is
            //      routed to these inputs.
            //  .numDestinations
            //      The number of valid outputs in the .inputs tuple.
            //  (many more properties available including filters)
            
            newParams.filterOutSysEx = 0        // 0 or 1
            newParams.filterOutMTC = 0          // 0 or 1
            newParams.filterOutBeatClock = 0    // 0 or 1
            newParams.filterOutTuneRequest = 0  // 0 or 1
            newParams.filterOutAllControls = 0  // 0 or 1
            
            return newParams
        }()
        
        // Source(s) and destination(s).
        // These expect tuples, so we have to perform some weirdness.
        // Rather than initialize MIDIThruConnectionEndpoint objects,
        // just access the .endpointRef property.
        // All 8 are pre-initialized MIDIThruConnectionEndpoint objects.
        
        for srcEP in 0..<outputs.count {
            switch srcEP {
            case 0: params.sources.0.endpointRef = outputs[0].coreMIDIObjectRef
            case 1: params.sources.1.endpointRef = outputs[1].coreMIDIObjectRef
            case 2: params.sources.2.endpointRef = outputs[2].coreMIDIObjectRef
            case 3: params.sources.3.endpointRef = outputs[3].coreMIDIObjectRef
            case 4: params.sources.4.endpointRef = outputs[4].coreMIDIObjectRef
            case 5: params.sources.5.endpointRef = outputs[5].coreMIDIObjectRef
            case 6: params.sources.6.endpointRef = outputs[6].coreMIDIObjectRef
            case 7: params.sources.7.endpointRef = outputs[7].coreMIDIObjectRef
            default: break // ignores more than 8 endpoints
            }
        }
        
        params.numSources = UInt32(outputs.count)
        
        for destEP in 0..<inputs.count {
            switch destEP {
            case 0: params.destinations.0.endpointRef = inputs[0].coreMIDIObjectRef
            case 1: params.destinations.1.endpointRef = inputs[1].coreMIDIObjectRef
            case 2: params.destinations.2.endpointRef = inputs[2].coreMIDIObjectRef
            case 3: params.destinations.3.endpointRef = inputs[3].coreMIDIObjectRef
            case 4: params.destinations.4.endpointRef = inputs[4].coreMIDIObjectRef
            case 5: params.destinations.5.endpointRef = inputs[5].coreMIDIObjectRef
            case 6: params.destinations.6.endpointRef = inputs[6].coreMIDIObjectRef
            case 7: params.destinations.7.endpointRef = inputs[7].coreMIDIObjectRef
            default: break // ignores more than 8 endpoints
            }
        }
        
        params.numDestinations = UInt32(inputs.count)
        
        // prepare params
        let pLen = MIDIThruConnectionParamsSize(&params)
        
        let paramsData = withUnsafePointer(to: &params) { ptr in
            NSData(bytes: ptr, length: pLen)
        }
        
        // non-persistent/persistent
        var cfPersistentOwnerID: CFString? = nil
        
        if case .persistent(ownerID: let ownerID) = lifecycle {
            cfPersistentOwnerID = ownerID as CFString
        }
        
        switch cfPersistentOwnerID {
        case nil:
            // non-persistent thru connection
            // there is a bug in CoreMIDI's Swift bridging whereby passing nil into MIDIThruConnectionCreate fails to create a non-persistent thru connection and actually creates a persistent thru connection, despite what the CoreMIDI documentation states.
            // This is a C function that wraps this method to accomplish this instead.
            try CMIDIThruConnectionCreateNonPersistent(
                paramsData,
                &newConnection
            )
            .throwIfOSStatusErr()
        case .some(let id):
            // persistent thru connection
            try MIDIThruConnectionCreate(
                id,
                paramsData,
                &newConnection
            )
            .throwIfOSStatusErr()
        }
        
        thruConnectionRef = newConnection
        
        switch lifecycle {
        case .nonPersistent:
            Log.debug("MIDI: Thru Connection: Successfully formed non-persistent connection.")
            
        case .persistent(let ownerID):
            Log.debug("MIDI: Thru Connection: Successfully formed persistent connection with ID \(ownerID.quoted).")
        }
        
    }
    
    /// Disposes of the the thru connection if it's already been created in the system via the `create()` method.
    ///
    /// Errors thrown can be safely ignored and are typically only useful for debugging purposes.
    internal func dispose() throws {
        
        guard let thruConnectionRef = self.thruConnectionRef else { return }
        
        defer {
            self.thruConnectionRef = nil
        }
        
        try MIDIThruConnectionDispose(thruConnectionRef)
            .throwIfOSStatusErr()
        
    }
    
}

extension MIDI.IO.ThruConnection: CustomStringConvertible {
    
    public var description: String {
        
        let thruConnectionRef = "\(self.thruConnectionRef, ifNil: "nil")"
        
        return "ThruConnection(ref: \(thruConnectionRef), outputs: \(outputs), inputs: \(inputs), \(lifecycle)"
        
    }
    
}

// MARK: - Lifecycle

extension MIDI.IO.ThruConnection {
    
    /// ThruConnection lifecycle type.
    public enum Lifecycle: Hashable {
        
        /// The play-through connection exists as long as the `Manager` exists.
        case nonPersistent
        
        /// The play-through connection is stored in the system and persists indefinitely (even after system reboots) until explicitly removed.
        ///
        /// - `ownerID`: Reverse-DNS domain string; usually the application's bundle ID.
        case persistent(ownerID: String)
        
    }
    
}

extension MIDI.IO.ThruConnection.Lifecycle: CustomStringConvertible {
    
    public var description: String {
        
        switch self {
        case .nonPersistent:
            return "nonPersistent"
            
        case .persistent(let ownerID):
            return "persistent(\(ownerID)"
        }
        
    }
    
}
